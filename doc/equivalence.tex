\documentclass{ijuc}
\usepackage[pdftex]{graphics}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{hyperref}

\begin{document}

\title{Combinatorial approach to counting equivalence classes in 1D and 2D cellular automata}
\author{Iztok Jeras\inst{1}\email{iztok.jeras@rattus.info}}
\institute{Faculty of Computer and Information Science, University of Ljubljana, Slovenia}
\def\received{Received 17 December 2004; In final form 1 April 2005}

\maketitle

\begin{abstract}
There is much more theoretical research on 1D cellular automata compared to 2D.
While not the only reason one of the arguments given is that the number of
available rules for a common 2D neighborhood is too large for a comprehensive
analysis. This issue can be mitigated by focusing on the smallest 2D neighborhoods
(trid and quad) and by grouping rules into equivalence classes. This article
gives an algebraic combinatorial solution to counting equivalence classes.
\end{abstract}

\keywords{cellular automata, combinatorics, equivalence classes, congruence operations}

\section{Introduction}

The focus of theoretical research is usually the simplest possible version of a system.
For 1D CA elementary rules are the simplest which exhibit not trivial behavior. Rule
equivalence has been used by many authors to organize 256 elementary CA rules into 88
equivalence classes. Representative rules from each class were then observed and described.
This approach found the most interesting rules which were then further analyzed. Rule 110
is a good example.

The same approach was never applied to 2D CA. For example most studied 2D rule is Game of Life.
It is based on a Moore neighborhood is binary cells. There are $2^{2^9}=2^512$ possible rules,
too many for a comprehensive analysis of the entire rule space. The von Neumann neighborhood
with $2^{2^5}=2^32$ rules is still impractical, and there is no rule with this neighborhood on
a binary lattice, whish would receive as much attention as Game of Life. While this two
neighborhoods were the focus of 2D CA research till recently, there are two simpler neighborhoods
named quad and trid which were popularized by Tommaso Toffoli only in 2008 using the QUAD prize competition.
The aim of the QUAD prize was to find a computation-universal 2-state cellular automaton on a 2-dimensional,
2Ã—2-neighborhood. Edward Powley proved computational universality on an even smaller neighborhood, the trid.

The focus of my CA research are preimages. On 1D CA de Bruijn diagrams are the main tool
used for this research. The size of this diagrams depends on the size of the rue space.
While once the algorithms for calculating preimages are known, the ability to compute
them is only limited by computer memory, the research of such algorithms usually requires
the ability of the researcher to model such problems with mathematical notations like
graphs and matrices. Only with 2D neighborhoods as small as quad and trid such representations
become small enough for theoretical analysis with the help of visual representations.

The purpose of this article is to calculate the number of equivalence classes for a few small
neighborhoods on a binary lattice (2D and 3D). The number of interesting rules can be further
reduced by removing rules which can be represented with a smaller neighborhood. This are rules
where one of the neighbors is not used in the local transition function, and higher order rules,
those that can be represented with multiple steps of a smaller neighborhood rule.

??? Most research on CA was recently done by Hidenosuke Nishio \cite{DBLP:journals/jca/Nishio12},
\cite{DBLP:journals/fuin/Nishio10}, \cite{DBLP:conf/ncma/Nishio09}, \cite{DBLP:conf/automata/NishioW08}.

Tommaso Toffoli
\url{http://uncomp.uwe.ac.uk/automata2008/files/quad.pdf}

Edward Powley
\url{http://uncomp.uwe.ac.uk/automata2008/files/quadprize_powley.pdf}

\section{Formalization}

I will skip the full CA formalization and will focus on aspects observed in this article.
What needs to be defined is the number of states of a cell, symmetries of the underlying lattice,
the neighborhood shape, and the rule value.

Each cell \(c\) can be in one of \(k\) states, which are numbered starting with 0.
\[ c \in {0, 1, ..., k-1} \]
There are \(k!\) permutations of the state set.
\[ \vert G^{per} \vert = k! \]

The underlaying lattice can have one or more dimensions. In 1D only reflection symmetry exists,
while in 2D there is also a 3, 4 or 6 fold rotation simmetry. 3D or lattices with even more
dimmensions are not discussed here, althoug the same principles can be applied there.

Regardless of the underlying lattice only two reflections, unchanged and mirrored.
\[ G^{ref} = {if, ref} \]
\[ \vert G^{ref} \vert = 2 \]

The number of rotations depends on the underlying lattice and is discussed for each neighborhood shape.

The neighborhood is defined by the number of cells \(m\) and its shape.
Only the trid and quad 2D neighborhoods will be discussed.
The neighborhood value is an ordered list of cell values.
\[ n = c_0, c_1, ..., c_{m-1} \]

\subsubsection{1D}

\subsubsection{2D trid}

\subsubsection{2D quad}

\section{Definition of Equivalence}

Two rules are equivalent, if a transformation for the CA state exists, such that each CA
current-next state pair for the current rule gets transformed into a current-next state pair
for the other rule.

State transition graphs for equivalent rules are of the same shape, and a transformation exists
which maps each state in one graph to a state at the same position in the graph for the other rule.

There are generalizations to this definition. For example a rule and it second order rule can be thought as equivalent.
(rule performing the same global transition in one step as the original rule achieves in two steps.

\subsection{1D problem}

Equivalence groups for elementary CA are long known. What is missing is a general algebraic solution.

\subsubsection{Symmetries}

There is a set of known symmetries or congruence operations on a given CA state.
For 1D CA this are reflection and permutation.

Reflection:

\[ G_{ref} = (id, ref) \]
\[ \vert G_{ref} \vert = 2 \]

Permutation:

\[ G_{per} = (id, per) \]
\[ \vert G_{per} \vert = k! \]

\subsubsection{Counting neighborhood values}

The set of all distinct neighborhood values $\mathbb{M}$ for a given neighborhood size $n$ and
number of cell states $k$ is:

\[ M = \left\{ m : \right\} \]
\[ \vert \mathbb{M} \vert = k^n \]

Neighborhood values can be organized into subsets depending on their invariance to congruence operations.

There are neighborhood values which are invariant to reflection. This are neighborhoos for which the
left half is the mirror is the mirror image of the right half. There are as many such neighborhood
values as there are possible values for a half sized neighborhood. For odd neighborhood sizes the middle
cell is always a mirror image of itself.

\[ \mathbb{M}_\mathrm{ref} = \left\{ \forall n \in \mathbb{M} : \phi_\mathrm{ref}(n) = n \right\} \]
\[ \vert \mathbb{M}_\mathrm{ref} \vert = \left\{ 
  \begin{array}{ll}
    {k^{m/2+1}} & \quad \textrm{if $m$ is odd }\\
    {k^{m/2  }} & \quad \textrm{if $m$ is even}
  \end{array} \right.
\]

There are no neighborhood values which are invariant to permutation.

\[ \mathbb{M}_\mathrm{per} = \left\{ \forall n \in \mathbb{M} : \phi_\mathrm{per}(n) = n \right\} = \varnothing \]
\[ \vert \mathbb{M}_\mathrm{per} \vert = 0 \]

There are neighborhood values which are invariant after both reflection and permutation have been applied.

\[ \mathbb{M}_\mathrm{ref,per} = \left\{ \forall n \in \mathbb{M} : \phi_\mathrm{per}(\phi_\mathrm{ref}(n)) = n \right\} \]
\[ \vert \mathbb{M}_\mathrm{ref,per} \vert = \left\{ 
  \begin{array}{ll}
    {0        } & \quad \textrm{if $m$ is odd }\\
    {k^{m/2  }} & \quad \textrm{if $m$ is even}
  \end{array} \right.
\]

\subsubsection{Counting rules}

Number of all rules \(\vert R \vert\):

\[ \vert R \vert = k^{\vert M \vert} = k^{k^n} \]

Rules which are invariant to reflection. The calculation is based on the number of
reflection invariant neightorhood values. The local transition function can take any
value for reflection invariant neighborhood values \(M^\mathrm{ref}\) while for the
rest \(M  \setminus M^\mathrm{ref}\) the same value must be used
for the the neighborhood value and its reflection.

\[ R^\mathrm{ref} = \left\{ \forall r \in R : \mathrm{ref}(r) = r \right\} \]
\[ \vert R^\mathrm{ref} \vert = k^{ \vert M^\mathrm{ref} \vert + \frac{\vert M \vert - \vert M^\mathrm{ref} \vert}{2} } = k^{ \frac{\vert M \vert + \vert M^\mathrm{ref} \vert}{2} } \]
\[ \vert R^\mathrm{ref} \vert = \left\{ 
  \begin{array}{ll}
    k^{\frac{k^m + k^{m/2+1}}{2}} & \quad \textrm{if $m$ is odd }\\
    k^{\frac{k^m + k^{m/2  }}{2}} & \quad \textrm{if $m$ is even}
  \end{array} \right.
\]

Rules which are invariant to permutation.

\[ R^\mathrm{per} = \left\{ \forall r \in R : \mathrm{per}(r) = r \right\} \]
\[ \vert R^\mathrm{per} \vert = k^{\vert M \vert / k} \]

Rules which are invariant to reflection and permutation applied at the same time.
First permutation limits free variables to \(k^{\vert M \vert / k}\), then reflection
limits them further by allowing a single free variable for all non reflective negighborhood values.
TODO: check this for correctness.

\[ R^\mathrm{ref \& per} = \left\{ \forall r \in R : \mathrm{per}(\mathrm{ref}(r)) = r \right\} \]
k=2
\[ \vert R^\mathrm{ref \& per} \vert = \left\{ 
  \begin{array}{ll}
    k^{1 + 1} & \quad \textrm{if $m$ is odd }\\
    k^{k + 1} & \quad \textrm{if $m$ is even}
  \end{array} \right.
\]
\subsubsection{Counting equivalence classes}

\url{https://en.wikipedia.org/wiki/Burnside%27s_lemma}

Burnside's lemma is used to count equivalence classes:

\[ |X/G| = \frac{1}{|G|}\sum_{g \in G}|X^g| \]

where G is 
\[ G_{ref} = (id, ref) \]
\[ G_{per} = (id, per) \]
\[ G = G_{ref} \times G_{per} = (id, ref, per, ref \& per) \]

\[ |X/G| = \frac{1}{2 \times k!} ( R + R^{ref} + (|G^{per}|-1)*(R^{per} + R^{per \& ref}) ) \]

Result for elementary CA (\(k=2\), \(n=3\))
\[ |X/G| = \frac{1}{4} (2^8 + 2^6 + 2^4 + 2^4) = 88 \]

\subsection{2D problem}

\subsubsection{Symetries}

In addition to reflection and permutation symetries already present in 1D CA,
2D CA also exihibit rotation simetry. The number of available rotations depends
on the underlaying lattice.

3-fold: trid
4-fold: quad, Moore, von Neumann neighborhood
6-fold: hexagonal lattice

\[ G_{rot} = (id, rot) \]
\[ \vert G_{per} \vert =  \]

Trid:

\[ G_{rot} = (id=rot0, rot1, rot2) \]
\[ \vert G_{per} \vert = 3 \]

\[ G = G_{ref} \times G_{per} \times G_{rot} = (id, ref, per, ref \& per, rot1, rot1 \& ref, rot1 \& per, rot2, rot2 \& ref, rot2 \& per) \]
\[ \vert G \vert = 12 \]

\[ |X/G| = \frac{1}{12} (2^8 + 2^6 + 2^4 + 2^4 + 2 (2^4 + 2^4 + 2^2 + 2^2)) = 36 \]

\section{Conclusion}

With elementary cellular automata the approach was to observe the evolution of
each rule and to further study the ones which exhibit interesting behavior.
A similar approach can be taken with 2D trid and quad. With an appropriate filter
this evolutions could be made into a video or a 3D image. An example filter would
convert each 3x3 neighborhood pattern probabilities into a color palette. For trid
a single person could do the review, while for quad crowd-sourcing could be used.

I hope will help further theoretical research into 2D CA.

\bibliography{equivalence}

\appendix 

\end{document}
